# .github/workflows/release.yml
name: Release

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      job_to_run:
        description: "Select job to run"
        required: false
        default: "all"
        type: choice
        options:
          - all
          - version-detection
          - build-artifact
          - release
          - deploy

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  # JOB 1: Configuration et d√©tection de version
  version-detection:
    name: Version Detection & Configuration
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    if: github.event_name == 'push' || inputs.job_to_run == 'all' || inputs.job_to_run == 'version-detection'
    outputs:
      do_release: ${{ steps.version.outputs.do_release }}
      next_version: ${{ steps.version.outputs.next_version }}
      app_id: ${{ steps.config.outputs.app_id }}
      app_name: ${{ steps.config.outputs.app_name }}
      app_description: ${{ steps.config.outputs.app_description }}
      schema_id: ${{ steps.config.outputs.schema_id }}
      schema_display_name: ${{ steps.config.outputs.schema_display_name }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      # NOUVEAU: Forcer la synchronisation avec la branche distante
      - name: Sync with remote branch
        run: |
          echo "üîÑ Synchronizing with remote branch..."
          git fetch origin
          git reset --hard origin/${{ github.ref_name }}
          echo "‚úÖ Branch synchronized"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Set branch-specific configuration
        id: config
        run: |
          # D√©finir les variables d'abord
          case "${{ github.ref_name }}" in
            main)
              APP_ID="my.sandbox"
              APP_NAME="Sandbox"
              APP_DESCRIPTION="Sandbox - Crafted by Phenisys."
              SCHEMA_ID="sandbox"
              SCHEMA_DISPLAY_NAME="Sandbox Demo"
              ;;
            develop)
              APP_ID="my.sandbox.development"
              APP_NAME="(Test) Sandbox"
              APP_DESCRIPTION="Sandbox - Crafted by Phenisys."
              SCHEMA_ID="sandbox-development"
              SCHEMA_DISPLAY_NAME="(Test) Sandbox"
              ;;
            *)
              APP_ID="my.sandbox.feature"
              APP_NAME="(Feature) Sandbox - ${{ github.ref_name }}"
              APP_DESCRIPTION="(Feature) Sandbox - Crafted by Phenisys."
              SCHEMA_ID="sandbox-feature"
              SCHEMA_DISPLAY_NAME="(Feature) Sandbox - ${{ github.ref_name }}"
              ;;
          esac

          # √âcrire dans GITHUB_OUTPUT
          echo "app_id=$APP_ID" >> $GITHUB_OUTPUT
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "app_description=$APP_DESCRIPTION" >> $GITHUB_OUTPUT
          echo "schema_id=$SCHEMA_ID" >> $GITHUB_OUTPUT
          echo "schema_display_name=$SCHEMA_DISPLAY_NAME" >> $GITHUB_OUTPUT

          # Afficher la configuration s√©lectionn√©e
          echo "üîß Selected Configuration for branch '${{ github.ref_name }}':"
          echo "  - App ID: $APP_ID"
          echo "  - App Name: $APP_NAME"
          echo "  - App Description: $APP_DESCRIPTION"
          echo "  - Schema ID: $SCHEMA_ID"
          echo "  - Schema Display Name: $SCHEMA_DISPLAY_NAME"

      - name: Install dependencies
        run: npm ci

      - name: Detect next version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        id: version
        run: |
          echo "üîç Detecting next version..."
          # Run semantic-release in dry-run mode to determine next version
          output=$(npx semantic-release --dry-run --no-ci 2>&1)
          echo "DEBUG: semantic-release output:"
          echo "$output"

          # Extract everything after "is " on the matching line (case insensitive)
          nextVersion=$(printf "%s" "$output" \
            | grep -oiE '[Tt]he next release version is .*' \
            | sed -E 's/^.*is (.*)$/\1/' \
            || true)

          if [ -z "$nextVersion" ]; then
            echo "no_version=true" >> $GITHUB_OUTPUT
            echo "do_release=false" >> $GITHUB_OUTPUT
            echo "next_version=" >> $GITHUB_OUTPUT
            echo "‚ùå No new version detected"
          else
            echo "no_version=false" >> $GITHUB_OUTPUT
            echo "do_release=true" >> $GITHUB_OUTPUT
            echo "next_version=$nextVersion" >> $GITHUB_OUTPUT
            echo "‚úÖ Next version detected: $nextVersion"
          fi

  # JOB 2: Build et g√©n√©ration d'artifact
  build-artifact:
    name: Build & Generate Artifact
    runs-on: ubuntu-latest
    needs: version-detection
    if: needs.version-detection.outputs.do_release == 'true' && (github.event_name == 'push' || inputs.job_to_run == 'all' || inputs.job_to_run == 'build-artifact')
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      # NOUVEAU: Forcer la synchronisation avec la branche distante
      - name: Sync with remote branch
        run: |
          echo "üîÑ Synchronizing with remote branch..."
          git fetch origin
          git reset --hard origin/${{ github.ref_name }}
          echo "‚úÖ Branch synchronized"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Update configuration files with version
        run: |
          VERSION="${{ needs.version-detection.outputs.next_version }}"

          echo "üîß Updating configuration with version: $VERSION"

          # Update app.config.json with version and branch-specific config
          jq --arg ver "$VERSION" \
             --arg id "${{ needs.version-detection.outputs.app_id }}" \
             --arg name "${{ needs.version-detection.outputs.app_name }}" \
             --arg desc "${{ needs.version-detection.outputs.app_description }}" \
             '.app.version = $ver | .app.id = $id | .app.name = $name | .app.description = $desc' \
             app.config.json > tmp.json && mv tmp.json app.config.json

          # Update schema file with branch config
          SCHEMA_FILE="settings/schemas/ms-teams-observability.schema.json"
          if [ -f "$SCHEMA_FILE" ]; then
            jq --arg schemaId "${{ needs.version-detection.outputs.schema_id }}" \
               --arg displayName "${{ needs.version-detection.outputs.schema_display_name }}" \
               '.schemaId = $schemaId | .displayName = $displayName' \
               "$SCHEMA_FILE" > tmp_schema.json && mv tmp_schema.json "$SCHEMA_FILE"
            echo "‚úÖ Schema file updated"
          else
            echo "‚ö†Ô∏è  Schema file not found: $SCHEMA_FILE"
          fi

      - name: Build application
        run: |
          echo "üèóÔ∏è  Building application..."
          npm run build
          echo "‚úÖ Build completed"

      - name: Generate deployment artifact
        env:
          DT_APP_OAUTH_CLIENT_ID: ${{ secrets.DT_APP_OAUTH_CLIENT_ID }}
          DT_APP_OAUTH_CLIENT_SECRET: ${{ secrets.DT_APP_OAUTH_CLIENT_SECRET }}
        run: |
          echo "üì¶ Generating deployment artifact..."
          npx dt-app deploy --skip-build --dry-run
          echo "‚úÖ Artifact generated"

      - name: Verify and upload artifact
        run: |
          if [ ! -f "./out/artifact.zip" ]; then
            echo "‚ùå Error: artifact.zip not found in ./out/"
            exit 1
          fi
          ARTIFACT_SIZE=$(du -h ./out/artifact.zip | cut -f1)
          echo "‚úÖ Artifact verified - Size: $ARTIFACT_SIZE"
          echo "üìã Artifact contains version: ${{ needs.version-detection.outputs.next_version }}"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-artifact-${{ needs.version-detection.outputs.next_version }}
          path: ./out/artifact.zip
          retention-days: 30

      # MODIFI√â: Ne pas faire de commit ici pour √©viter les conflits avec semantic-release
      - name: Prepare configuration changes
        run: |
          echo "üíæ Configuration changes prepared for commit after release..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

  # JOB 3: Release GitHub
  release:
    name: GitHub Release
    runs-on: ubuntu-latest
    needs: [version-detection, build-artifact]
    if: needs.version-detection.outputs.do_release == 'true' && (github.event_name == 'push' || inputs.job_to_run == 'all' || inputs.job_to_run == 'release')
    permissions:
      contents: write
      issues: write
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      # NOUVEAU: Forcer la synchronisation avec la branche distante
      - name: Sync with remote branch
        run: |
          echo "üîÑ Synchronizing with remote branch..."
          git fetch origin
          git reset --hard origin/${{ github.ref_name }}
          echo "‚úÖ Branch synchronized"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: deployment-artifact-${{ needs.version-detection.outputs.next_version }}
          path: ./out/

      # NOUVEAU: Appliquer les changements de configuration avant la release
      - name: Apply configuration changes
        run: |
          VERSION="${{ needs.version-detection.outputs.next_version }}"
          echo "üîß Applying configuration changes for version: $VERSION"

          # Update app.config.json with version and branch-specific config
          jq --arg ver "$VERSION" \
             --arg id "${{ needs.version-detection.outputs.app_id }}" \
             --arg name "${{ needs.version-detection.outputs.app_name }}" \
             --arg desc "${{ needs.version-detection.outputs.app_description }}" \
             '.app.version = $ver | .app.id = $id | .app.name = $name | .app.description = $desc' \
             app.config.json > tmp.json && mv tmp.json app.config.json

          # Update schema file with branch config
          SCHEMA_FILE="settings/schemas/ms-teams-observability.schema.json"
          if [ -f "$SCHEMA_FILE" ]; then
            jq --arg schemaId "${{ needs.version-detection.outputs.schema_id }}" \
               --arg displayName "${{ needs.version-detection.outputs.schema_display_name }}" \
               '.schemaId = $schemaId | .displayName = $displayName' \
               "$SCHEMA_FILE" > tmp_schema.json && mv tmp_schema.json "$SCHEMA_FILE"
            echo "‚úÖ Schema file updated"
          fi

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üöÄ Creating GitHub release for version ${{ needs.version-detection.outputs.next_version }}..."
          # Configurer git pour semantic-release
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Ex√©cuter semantic-release
          npx semantic-release
          echo "‚úÖ GitHub release created"

      - name: Commit and push configuration changes
        run: |
          VERSION="${{ needs.version-detection.outputs.next_version }}"
          SCHEMA_FILE="settings/schemas/ms-teams-observability.schema.json"

          # V√©rifier s'il y a des changements √† committer
          if git diff --quiet app.config.json "$SCHEMA_FILE" 2>/dev/null || git diff --quiet app.config.json 2>/dev/null; then
            echo "‚ÑπÔ∏è  No changes in configuration files; skipping commit and push."
          else
            echo "üíæ Committing and pushing configuration changes..."
            git add app.config.json
            if [ -f "$SCHEMA_FILE" ]; then
              git add "$SCHEMA_FILE"
            fi
            git commit -m "chore: update configuration files to version $VERSION [skip ci]"
            git push origin ${{ github.ref_name }}
            echo "‚úÖ Configuration changes committed and pushed"
          fi

  # JOB 4: D√©ploiement Dynatrace
  deploy:
    name: Deploy to Dynatrace
    runs-on: ubuntu-latest
    environment: dynatrace
    needs: [version-detection, build-artifact, release]
    if: needs.version-detection.outputs.do_release == 'true' && (github.event_name == 'push' || inputs.job_to_run == 'all' || inputs.job_to_run == 'deploy')

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      # NOUVEAU: R√©cup√©rer la derni√®re version avec les tags
      - name: Sync with remote and get latest version
        run: |
          echo "üîÑ Synchronizing with remote branch and tags..."
          git fetch origin --tags
          git reset --hard origin/${{ github.ref_name }}
          echo "‚úÖ Branch and tags synchronized"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      # NOUVEAU: Appliquer les changements de configuration pour le d√©ploiement
      - name: Apply configuration changes
        run: |
          VERSION="${{ needs.version-detection.outputs.next_version }}"
          echo "üîß Applying configuration changes for deployment: $VERSION"

          # Update app.config.json with version and branch-specific config
          jq --arg ver "$VERSION" \
             --arg id "${{ needs.version-detection.outputs.app_id }}" \
             --arg name "${{ needs.version-detection.outputs.app_name }}" \
             --arg desc "${{ needs.version-detection.outputs.app_description }}" \
             '.app.version = $ver | .app.id = $id | .app.name = $name | .app.description = $desc' \
             app.config.json > tmp.json && mv tmp.json app.config.json

          # Update schema file with branch config
          SCHEMA_FILE="settings/schemas/ms-teams-observability.schema.json"
          if [ -f "$SCHEMA_FILE" ]; then
            jq --arg schemaId "${{ needs.version-detection.outputs.schema_id }}" \
               --arg displayName "${{ needs.version-detection.outputs.schema_display_name }}" \
               '.schemaId = $schemaId | .displayName = $displayName' \
               "$SCHEMA_FILE" > tmp_schema.json && mv tmp_schema.json "$SCHEMA_FILE"
            echo "‚úÖ Schema file updated"
          fi

      - name: Build application
        run: |
          echo "üèóÔ∏è  Building application..."
          npx dt-app build
          echo "‚úÖ Build completed"

      - name: Print Commits
        run: |
          echo "üìú Commits since last release:"
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "No previous tag")
          if [ "$LAST_TAG" != "No previous tag" ]; then
            git log --pretty=format:"%h - %s (%an)" --no-merges ${LAST_TAG}..HEAD
          else
            echo "No previous tag found, showing last 10 commits:"
            git log --pretty=format:"%h - %s (%an)" --no-merges -10
          fi

      - name: Deploy to Dynatrace
        env:
          DT_APP_OAUTH_CLIENT_ID: ${{ secrets.DT_APP_OAUTH_CLIENT_ID }}
          DT_APP_OAUTH_CLIENT_SECRET: ${{ secrets.DT_APP_OAUTH_CLIENT_SECRET }}
        run: |
          echo "üöÄ Deploying to Dynatrace..."
          echo "üìã Version: ${{ needs.version-detection.outputs.next_version }}"
          echo "üìã App ID: ${{ needs.version-detection.outputs.app_id }}"
          npx dt-app deploy --skip-build
          echo "‚úÖ Deployment to Dynatrace completed"

  # JOB 5: R√©sum√© du workflow
  workflow-summary:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs: [version-detection, build-artifact, release, deploy]
    if: always() && (github.event_name == 'push' || inputs.job_to_run == 'all')

    steps:
      - name: Workflow Summary
        run: |
          echo "# üìä Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Results:" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version Detection:** ${{ needs.version-detection.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build & Artifact:** ${{ needs.build-artifact.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **GitHub Release:** ${{ needs.release.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Dynatrace Deploy:** ${{ needs.deploy.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.version-detection.outputs.do_release }}" == "true" ]; then
            echo "## üéâ Release Information:" >> $GITHUB_STEP_SUMMARY
            echo "- **Version:** ${{ needs.version-detection.outputs.next_version }}" >> $GITHUB_STEP_SUMMARY
            echo "- **App ID:** ${{ needs.version-detection.outputs.app_id }}" >> $GITHUB_STEP_SUMMARY
            echo "- **App Name:** ${{ needs.version-detection.outputs.app_name }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ÑπÔ∏è No release created (no version bump needed)" >> $GITHUB_STEP_SUMMARY
          fi
